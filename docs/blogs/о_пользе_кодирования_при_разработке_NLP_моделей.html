---
title: О пользе кодирования при разработке NLP моделей
author: Dmitriy Monakhov
avatar_url: images/monakhov.png
publish_date: Jul 31, 2019
flag-ico: images/ru-flag-128x128.png
layout: blog
---

<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<section>
    <div class="blog-header">
        <div class="blog-title">{{page.title}}</div>
        <div class="blog-sub-title">
            <img class="avatar-img" src="{{ page.avatar_url | relative_url}}">
            <span class="blog-author text-nowrap">{{ page.author }}</span>
            <img class="flag-img" src="{{ page.flag-ico | relative_url}}">
            <span class="text-nowrap blog-date">{{ page.publish_date }}</span>
        </div>
    </div>
    <p>
        Множество NLP решений декларируют, что они “не требует навыков программирования” при работе с ними.
        Мало того, они преподносят это как плюс.
        Не стоит даже спорить, для экстремально простых решений подобное ограничение и правда является плюсом.
        Мы лишь попробуем привести несколько разрозненных примеров, когда без написания кода трудно сделать хоть
        что-нибудь достаточно полезное для построения собственных моделей обработки пользовательских запросов.
    </p>
    <p>
        NLPCraft предполагает, что разработчики NLP решений, опирающихся на нашу систему, будут в той или иной степени
        использовать программирование. Далее, опираясь на примеры, мы постараемся обосновать достоинства такого подхода.
    </p>
    <div class="blog-h1">Программное добавление синонимов</div>
    <p>
        Мы уже писали о <a target=_ href="https://medium.com/@dmonakhov_47478/поиск-в-тексте-элементов-семантической-модели-по-определенным-для-них-синонимам-8cd9e1bcd6d7">поиске сущностей в тексте</a>,
        основанном на определении синонимов.
        Этот способ является самым распространенным и надежным механизмом поиска элементов.
        Далее, именованные сущности мы будем обозначать как <a target=_ href="https://www.wikiwand.com/en/Named-entity_recognition">NE</a>.
        Для целого ряда NE синонимы могут быть смело сконфигурированы раз и навсегда.
    </p>
    <p>
        Остаются вопросы:
    </p>
    <ul>
        <li>
            Как быть, если таких синонимов очень много и они динамически обновляются?
        </li>
        <li>
            Что если вам необходимо расширить существующий набор синонимов, руководствуясь какими-то правилами?
        </li>
    </ul>
    <p>
        Рассмотрим пример - вы предоставляете интерфейс для выдачи информации о погоде в горных массивах.
        Названия и координаты гео объектов находятся в вашей базе данных.
    </p>
    <p>
        Когда невозможно обойтись без кодирования:
    </p>
    <ul>
        <li>
            C задачей загрузить ваши данные (названия гео объектов) из базы в модель может справиться только ваш код.
        </li>
        <li>
            Дополнительно вам может понадобиться программно обогатить список синонимов.
            В рассматриваемом случае, к характерным для специфики разрабатываемой модели географическим названиям
            вроде <b>mountain altai</b>, вы можете добавить такие синонимы как <b>mt altai</b> и <b>mt. altai</b>,
            значительно расширив, таким образом, возможности вашей системы по распознаванию объектов.
            Нейросети не всегда смогут помочь вам в задачах подобного рода.
        </li>
   </ul>
    <div class="blog-h1">Механизм распознавания элементов в тексте, основанный на <code>regexp</code></div>
    <p>
        Какие дополнительные средства распознавания элементов могут быть применены?
        С помощью регулярного выражения <b>^\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,3}$</b>
        (взято с <a target=_ href="http://regexlib.com/Search.aspx?k=email&AspxAutoDetectCookieSupport=1">сайта, посвященного регулярным выражениям</a>)
        вы можете почти гарантированно выявить в тексте запроса адреса электронной почты.
        Подобный подход является наиболее предпочтительным при поиске NE, поддающихся подобной формализации.
    </p>
    <div class="bq info">
        Плюсы - экономия памяти приложения, компактность.
        <br>
        Минусы - сравнительно медленная обработка.
    </div>
    <p>
        Можно, разумеется, сказать что это не программирование, а задача конфигурации. Хорошо, усложним требования.
    </p>
    <div class="blog-h1">Предикаты для обнаружения сущностей</div>
    <p>
        Не всегда так легко или даже возможно написать регулярное выражение,
        однозначно определяющее какой-то элемент.
        Иногда проще и надежнее понять, является ли какое-либо слово NE с помощью запрограммированной функции.
        К тому же данное решение гораздо гибче.
        Документация на использование подобных предикатов доступна по <a target=_ href="https://nlpcraft.org/apis/javadoc-0.7.1/org/nlpcraft/model/intent/NCIntentSolver.TERM.html#TERM-java.util.function.Function-">ссылке</a>.
        Рассмотрим пример кода.
    </p>
    <pre class="brush: java, highlight: []">
        private def checkMatch(t: NCToken): java.lang.Boolean = {
            val txt = getNormalizedText(t)

            txt.length == 10 && txt.head.isDigit || txt.length == 8 && txt.head.isUpper
        }
    </pre>
    <p>
        <code>checkMatch</code> функция вернет <code>true</code>, только если длина слова равна <code>10</code> и оно
        начинается с цифры, или если длина слова равна <code>8</code> и оно начинается с буквы в верхнем регистре.
        Вы можете использовать тут регулярное выражение? Отлично! Но это же просто пример...
    </p>
    <div class="bq info">
        Подключение в NLP цепочку подобных предикатов очень удобно для поиска в тексте каких-либо идентификаторов или
        других вариантов технических данных.
    </div>
    <div class="blog-h1">Как обнаружить сущности, опираясь на весь текст запроса</div>
    <p>
        Пусть Вам требуется определить, является ли слово или словосочетание NE, основываясь не только на самом слове
        (его лемме, стемме и части речи), но и на тексте в целом.
        Документация на компонент приведена по <a target=_ href="https://nlpcraft.org/apis/latest/org/nlpcraft/model/parsing/NCCustomParser.html">ссылке</a>.
    </p>
    <pre class="brush: java, highlight: []">
        class MyParser extends NCCustomParser {
            private final val YES_WORDS: Set[String] = Set("yes", "y")
            private final val PUNCTUATION: Set[String] = Set(".", ",")

            // Finds `x:noun` elements.
            // Condition of search:
            // 1. First sentence's word must be confirmation (word `yes`).
            // 2. Others words should be single noun which we try to find and any count of punctuation marks.
            override def parse(senJava: util.List[NCCustomWord]): util.List[NCCustomElement] = {
                var sen = senJava.asScala

                if (YES_WORDS.contains(sen.head.getNormText)) {
                    sen = sen.drop(1).filter(p ⇒ !PUNCTUATION.contains(p.getPos))

                    if (sen.length == 1 && sen.head.getPos.head == 'N')
                        Collections.singletonList(
                            new NCCustomElement {
                                override def getElementId: String = "x:noun"
                                override def getWords: util.List[NCCustomWord] = Collections.singletonList(sen.head)
                                override def getMetadata: util.Map[String, AnyRef] = Collections.emptyMap()
                            }
                        )
                    else
                        null
                }
                else
                    null
            }
        }
    </pre>
    <p>
        C помощью функции <code>parse</code> элемент <code>x:noun</code> будет успешно обнаружен,
        только если он является существительным, стоящим за неким утвердительным словом. Знаки препинания игнорируются.
        Даже такую несложную логику проблемно реализовать иначе, чем с помощью кодирования.
        А реализовать такой интерфейс и подключить имплементацию parser к общей NLP цепочке не составит труда.
        Также, практически невозможно обойтись без подобного рода программных компонентов в случаях,
        когда алгоритм определения NE недетерминирован.
        Напрмиер, если в дневное время мы определяем некую сущность по каким-то критериям, а в ночное время нет,
        то программирование подобной логики - это единственно разумная реализация.
    </p>
    <div class="blog-h1">Интенты, условия обнаружения</div>
    <p>
        Некоторые системы, претендующие на простоту использования, действительно позволяют создавать очень простые интенты
        очень простым способом.
        Например, пусть интент ”погода” должен сработать тогда, когда в тексте запроса обнаружены следующие сущности:
    </p>
    <ul>
        <li>
            элемент <code>погода</code> (обязательный) и
        </li>
        <li>
            элемент <code>гео</code> (опциональный)
        </li>
    </ul>
    <p>
        Примеры вопросов:
        "расскажи мне о <code>погоде</code>" или "расскажи мне о <code>погоде</code> в <code>Лондоне</code>".
    </p>
    <p>
        То есть интенты в таких системах определяются как списки элементов с флагами, являются или нет указанные
        элементы обязательными для конфигурируемого интента.
        Пусть для 90% случаев использования этого способа определения интентов окажется достаточным.
        Но что делать с оставшимися 10%?
        Бывают ситуации, когда условие срабатывания интента приходится представлять как относительно сложное булево
        выражение, а иногда и с дополнительными ограничениями, накладываемыми на метаданные найденного элемента.
    </p>
    <p>
        Так, например, следующее условие интента <code>term(nums)={id=='nlpcraft:num' && ~NUM_UNITTYPE=='datetime'}</code>
        (DSL определение) заставит его сработать, только если найденные в запросе числовые значения имеют
        тип <code>datetime</code>.
    </p>
    <p>
        Приведенный ниже пример программного определения интента сработает лишь для именованных сущностей типа
        <code>ORGANIZATION</code>, <code>PERSON</code> или <code>NUMBER</code>.
    </p>
    <pre class="brush: java, highlight: []">
        new INTENT(
            "action",
            false,
            new TERM("id == 'phone:act'", 1, 1),
            new TERM(
                "rcpt",
                new OR(
                    "id == 'google:organization'",
                    "id == 'google:person'",
                    "id == 'google:phone_number'"
                ),
            1,
            3
            )
        )
    </pre>
    <div class="blog-h1">Поддержка сессионности</div>
    <p>
        При определении условия срабатывания интента бывает полезной возможность указать в конфигурации,
        является ли описываемый интент сессионным, то есть должно ли состояние памяти между вопросами оказывать влияние
        на условие его срабатывания.
        Для сессионных интентов также может быть полезна возможность управления состоянием памяти в рамках сессии,
        то есть между вопросами, и нет никаких других способов управления этим состоянием,
        кроме как путем вызовов из вашего кода.
    </p>
    <div class="blog-h1">Собственная схема матчинга интентов</div>
    <p>
        А что, если у вашей системы своя модель поиска интентов, свой совершенно особый принцип, основанный на выбранных
        вами алгоритмах, AI решениях, обученных нейросетях и так далее. Вы сможете задействовать ее, подключив
        соответствующий программный код в общую NLP цепочку обработки запросов NLPCraft.
    </p>
    <div class="blog-h1">Обработка интентов</div>
    <p>
        Иногда логика работы с интентами может быть весьма изощренной.
        Предположим, вы нашли элемент <code>x:noun</code>, принцип обнаружения которого продемонстрирован в примере выше.
        Пусть элемент найден, какой-то интент сработал, но далее, в коде вызова, связанного интентом,
        вы каким-то образом обнаружили, что произошло ложное срабатывание и следовало бы вызвать совсем другой интент
        или обработчик запроса по умолчанию.
        В отличие от систем “без использования кода”, NLPCraft предоставляет разработчику NLP решения возможность
        передумать даже в этот, казалось бы уже самый последний момент, и передать управления матчеру для поиска других,
        более подходящих интентов. Cмотри описание <a target=_ href="https://nlpcraft.org/apis/latest/org/nlpcraft/model/intent/NCIntentSkip.html">NCSkip</a>.
    </p>
    <div class="blog-h1">Model-as-a-code</div>
    <p>
        Сравните структуру классического проекта, который можно собирать и редактировать в IDE,
        использовать средства контроля версий и так далее с проектом, некоторые части которого раскиданы по файлам,
        созданным с помощью web редакторов, а другие части хранятся в репозиториях компании.
        Как только ваш проект выйдет из стадии “Hello, world”, подобная структура станет как минимум головной болью.
        Мы ни в коем случае не отрицаем выгоду от выноса конфигураций синонимов и моделей в отдельные файлы, править
        которые могут специалисты различных направленностей, мы говорим скорее об общей структуре и принципе ведения и
        поддержки проектов, создании “models-as-a-code”.
    </p>
    <div class="blog-h1">Краткие выводы</div>
    <p>
        Список примеров легко продолжить, но уже на основании описанных проблем, можно уверенно утверждать,
        что для разработки реальных систем вам придется добавить в ваши модели “немного программного кода”.
        Мы в NLPCraft считаем, что только таким образом можно обеспечить всю необходимую гибкость при создании моделей,
        которой так не хватает при работе с решениями, “не требующими навыков программирования”.
    </p>
</section>